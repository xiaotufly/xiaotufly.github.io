{"pages":[{"title":"","text":"一只兔子","link":"/about/index.html"}],"posts":[{"title":"first","text":"HELLO WORLD1234567#include&lt;iostream&gt;using namespace std;int main(){ cout&lt;&lt;\"HELLO WORLD\"; return 0;}","link":"/2019/07/11/first/"},{"title":"Snake","text":"贪吃蛇学年设计的时候做的贪吃蛇，只是简单的做出来基本操作，写的代码从时间和空间上看都不是很优。 这里讲一下大概思路： 一条蛇不停的移动， 玩家将控制蛇的方向，蛇在吃掉食物后，将会重新生成食物，若蛇吃到自己的身体或撞到边框则结束游戏并显示得分。 一个最简贪吃蛇游戏需要3个部分： 1.地图 2.蛇移动 3.食物 地图地图使用了坐标函数设置，画一个框 移动贪吃蛇的移动分为按键控制与在未有按键输入时向原方向移动。 按键控制使用kbhit()函数接受即可设置蛇的移动。 在未出现按键输入时，蛇将不停的向原方向移动(将每个蛇的坐标向前覆盖并清除最后一个坐标)，还需要使用sleep()函数与循环。 sleep()函数可以在一定时间让蛇停下来(不然刚开局就死掉了)。 食物食物需要在蛇吃掉后随机生成，且不能生成在蛇的身上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296#include&lt;iostream&gt;#include &lt;windows.h&gt; #include&lt;ctime&gt;#include&lt;queue&gt;#include&lt;conio.h&gt;//内含有kbhit()函数 在VC里面有这个头文件#define Up 119//72 #define Down 115 //80 #define Left 97 //75#define Right 100 //77#define Enter 13//上，下，左，右//system(\"cls\");//清屏函数 using namespace std;//////////全局变量////////////HANDLE hOut,hIn,hwnd;bool alive;//是否存活int grade=0;//得分char key;char direction;//方向bool kk=false;int length=2;//初始长度bool f=false;//是否已经生成食物int sx[100];//snake横坐标int sy[100];//snake纵坐标int food_x;//food横坐标int food_y;//food纵坐标int x,y,QAQ;char QWQ;///////////////////////////////void HideCursor(int n) /*隐藏光标*/{ CONSOLE_CURSOR_INFO cursor_info={1,n}; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE),&amp;cursor_info);}//////////////颜色函数/////////////////int color(int c){ hOut=GetStdHandle(STD_OUTPUT_HANDLE);//获取字符输出句柄 SetConsoleTextAttribute(hOut,c);//改变颜色 return 0; } void setXY(int x,int y) //移动坐标{ COORD coord; coord.X=x; coord.Y=y; SetConsoleCursorPosition( GetStdHandle( STD_OUTPUT_HANDLE ), coord );}///////////////////////////////////// ////////////画图///////////////////void Interface_Design(){ for(int i=0;i&lt;24;i++) { setXY(0,i); cout&lt;&lt;\"#\"; setXY(40,i); cout&lt;&lt;\"#\"; } for(int i=0;i&lt;=40;i++) { setXY(i,0); cout&lt;&lt;\"#\"; setXY(i,24); cout&lt;&lt;\"#\"; } setXY(50,20); cout&lt;&lt;\"操作\"; setXY(50,22); cout&lt;&lt;\"w s a d 控制上下左右\";}/////////////////////////////////////////////////画蛇//////////////////// void snake(){ for(int i=0;i&lt;length;i++) { setXY(sx[i],sy[i]); if(i==0) cout&lt;&lt;\"@\"; else cout&lt;&lt;\"*\"; }}void xY(){ for(int i=length-1;i&gt;=1;i--) { sx[i]=sx[i-1]; sy[i]=sy[i-1]; }}//坐标移动 ///////////////////////////////////////// void food() { int x,y; srand((unsigned int)time(NULL)); int ww=1; while(ww) { for(int i=0;i&lt;20;i++) { x=rand()%(20-4)+2; y=rand()%(20-2)+1; } for(int i=0;i&lt;length;i++) { ww=0; if(sx[i]==x&amp;&amp;sy[i]==y) { ww=1; break; } }//不能再蛇的身体上生成食物 } setXY(x,y); food_x=x; food_y=y; cout&lt;&lt;'$'; f=true;}//食物生成函数 void L(){ if(sx[0]==food_x&amp;&amp;sy[0]==food_y) { f=false; length++; sx[length-1]=sx[length-2]; sy[length-1]=sy[length-2]; }}//对蛇是否吃掉食物进行判定，并增加蛇的长度////////////方向控制 ////////////////void Control_Direction(){ switch(key) { case Up: direction=Up; L(); setXY(sx[length-1],sy[length-1]); cout&lt;&lt;\" \";xY(); sy[0]--; setXY(sx[0],sy[0]); snake(); break; case Down:direction=Down; L(); setXY(sx[length-1],sy[length-1]); cout&lt;&lt;\" \"; xY(); sy[0]++; setXY(sx[0],sy[0]); snake(); break; case Left:direction=Left; L(); setXY(sx[length-1],sy[length-1]); cout&lt;&lt;\" \";xY(); sx[0]--; setXY(sx[0],sy[0]); snake(); break; case Right:direction=Right; L(); setXY(sx[length-1],sy[length-1]); cout&lt;&lt;\" \";xY(); sx[0]++; setXY(sx[0],sy[0]); snake(); break; }} //////////////////////////////////////////////////////死亡/////////////////void dead(){ if(sx[0]&gt;39||sx[0]&lt;1||sy[0]&lt;1||sy[0]&gt;23) { alive=false; } for(int i=1;i&lt;length;i++) { if(sx[0]==sx[i]&amp;&amp;sy[0]==sy[i]) { alive=false; } }}///////////////////////////////////// ////////////////菜单///////////////////int menu(){ setXY(50,5); cout&lt;&lt;\" 贪吃蛇游戏\"&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl; setXY(50,10); cout&lt;&lt;\" 普通模式\"&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl; setXY(50,15); cout&lt;&lt;\" 困难模式\"&lt;&lt;endl; setXY(15,25); cout&lt;&lt;\"w s上下选择 回车 确认选择\"; setXY(30,10); while(kbhit()) { HideCursor(0); QWQ=getch(); if(QWQ==Up) { setXY(30,15); cout&lt;&lt;\" \"; setXY(30,10); cout&lt;&lt;\"---------&gt;&gt;&gt;\"; x=30; y=10; } else if(QWQ==Down) { setXY(30,10); cout&lt;&lt;\" \"; setXY(30,15); cout&lt;&lt;\"---------&gt;&gt;&gt;\"; x=30; y=15; } else if(QWQ==13) { if(y==10) return 1; if(y==15) return 2; } }} /////////////////////////////////////int main(){ int mm=1; HideCursor(0); x=30;y=10; setXY(30,10); cout&lt;&lt;\"---------&gt;&gt;&gt;\"; while(QWQ!=13) { Sleep(200); mm=menu(); } system(\"cls\");//清屏函数 setXY(5,5); if(mm==1) QAQ=200; else if(mm==2) QAQ=170-length*2; color(3); HideCursor(0); alive=true; srand(time(NULL)); Interface_Design(); //界面设计 sx[0]=5; sy[0]=5; sx[1]=4; sy[1]=5; snake(); key=Right; direction=0; while(1) { color(6); if(!f)food(); color(2); Sleep(QAQ); if(kbhit()) { if((key=getch())==-32) key=getch(); } if(key==Up&amp;&amp;direction==Down) key=Down; else if(key==Down&amp;&amp;direction==Up) key=Up; else if(key==Right&amp;&amp;direction==Left) key=Left; else if(key==Left&amp;&amp;direction==Right) key=Right; Control_Direction(); dead(); if(!alive) break; setXY(50,25); cout&lt;&lt;\"得分:\"&lt;&lt;(length-2)*2&lt;&lt;endl; } color(7); system(\"cls\");//清屏函数 cout&lt;&lt;\"GAME OVER\"&lt;&lt;endl; cout&lt;&lt;\"得分:\"&lt;&lt;(length-2)*2&lt;&lt;endl; system(\"pause\");return 0; } 这里我还加了颜色改变和主菜单，也十分简单，使用坐标函数即可。 如果想要显示最高分的话我想的是使用文件那一块的知识。","link":"/2019/07/23/Snake/"}],"tags":[{"name":"daily","slug":"daily","link":"/tags/daily/"}],"categories":[]}