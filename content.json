{"pages":[{"title":"","text":"一只兔子","link":"/about/index.html"}],"posts":[{"title":"Snake","text":"贪吃蛇 学年设计的时候做的贪吃蛇，只是简单的做出来基本操作，写的代码从时间和空间上看都不是很优。 这里讲一下大概思路： 一条蛇不停的移动， 玩家将控制蛇的方向，蛇在吃掉食物后，将会重新生成食物，若蛇吃到自己的身体或撞到边框则结束游戏并显示得分。 一个最简贪吃蛇游戏需要3个部分： 1.地图 2.蛇移动 3.食物 地图地图使用了坐标函数设置，画一个框 移动贪吃蛇的移动分为按键控制与在未有按键输入时向原方向移动。 按键控制使用kbhit()函数接受即可设置蛇的移动。 在未出现按键输入时，蛇将不停的向原方向移动(将每个蛇的坐标向前覆盖并清除最后一个坐标)，还需要使用sleep()函数与循环。 sleep()函数可以在一定时间让蛇停下来(不然刚开局就死掉了)。 食物食物需要在蛇吃掉后随机生成，且不能生成在蛇的身上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296#include&lt;iostream&gt;#include &lt;windows.h&gt; #include&lt;ctime&gt;#include&lt;queue&gt;#include&lt;conio.h&gt;//内含有kbhit()函数 在VC里面有这个头文件#define Up 119//72 #define Down 115 //80 #define Left 97 //75#define Right 100 //77#define Enter 13//上，下，左，右//system(\"cls\");//清屏函数 using namespace std;//////////全局变量////////////HANDLE hOut,hIn,hwnd;bool alive;//是否存活int grade=0;//得分char key;char direction;//方向bool kk=false;int length=2;//初始长度bool f=false;//是否已经生成食物int sx[100];//snake横坐标int sy[100];//snake纵坐标int food_x;//food横坐标int food_y;//food纵坐标int x,y,QAQ;char QWQ;///////////////////////////////void HideCursor(int n) /*隐藏光标*/{ CONSOLE_CURSOR_INFO cursor_info={1,n}; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE),&amp;cursor_info);}//////////////颜色函数/////////////////int color(int c){ hOut=GetStdHandle(STD_OUTPUT_HANDLE);//获取字符输出句柄 SetConsoleTextAttribute(hOut,c);//改变颜色 return 0; } void setXY(int x,int y) //移动坐标{ COORD coord; coord.X=x; coord.Y=y; SetConsoleCursorPosition( GetStdHandle( STD_OUTPUT_HANDLE ), coord );}///////////////////////////////////// ////////////画图///////////////////void Interface_Design(){ for(int i=0;i&lt;24;i++) { setXY(0,i); cout&lt;&lt;\"#\"; setXY(40,i); cout&lt;&lt;\"#\"; } for(int i=0;i&lt;=40;i++) { setXY(i,0); cout&lt;&lt;\"#\"; setXY(i,24); cout&lt;&lt;\"#\"; } setXY(50,20); cout&lt;&lt;\"操作\"; setXY(50,22); cout&lt;&lt;\"w s a d 控制上下左右\";}/////////////////////////////////////////////////画蛇//////////////////// void snake(){ for(int i=0;i&lt;length;i++) { setXY(sx[i],sy[i]); if(i==0) cout&lt;&lt;\"@\"; else cout&lt;&lt;\"*\"; }}void xY(){ for(int i=length-1;i&gt;=1;i--) { sx[i]=sx[i-1]; sy[i]=sy[i-1]; }}//坐标移动 ///////////////////////////////////////// void food() { int x,y; srand((unsigned int)time(NULL)); int ww=1; while(ww) { for(int i=0;i&lt;20;i++) { x=rand()%(20-4)+2; y=rand()%(20-2)+1; } for(int i=0;i&lt;length;i++) { ww=0; if(sx[i]==x&amp;&amp;sy[i]==y) { ww=1; break; } }//不能再蛇的身体上生成食物 } setXY(x,y); food_x=x; food_y=y; cout&lt;&lt;'$'; f=true;}//食物生成函数 void L(){ if(sx[0]==food_x&amp;&amp;sy[0]==food_y) { f=false; length++; sx[length-1]=sx[length-2]; sy[length-1]=sy[length-2]; }}//对蛇是否吃掉食物进行判定，并增加蛇的长度////////////方向控制 ////////////////void Control_Direction(){ switch(key) { case Up: direction=Up; L(); setXY(sx[length-1],sy[length-1]); cout&lt;&lt;\" \";xY(); sy[0]--; setXY(sx[0],sy[0]); snake(); break; case Down:direction=Down; L(); setXY(sx[length-1],sy[length-1]); cout&lt;&lt;\" \"; xY(); sy[0]++; setXY(sx[0],sy[0]); snake(); break; case Left:direction=Left; L(); setXY(sx[length-1],sy[length-1]); cout&lt;&lt;\" \";xY(); sx[0]--; setXY(sx[0],sy[0]); snake(); break; case Right:direction=Right; L(); setXY(sx[length-1],sy[length-1]); cout&lt;&lt;\" \";xY(); sx[0]++; setXY(sx[0],sy[0]); snake(); break; }} //////////////////////////////////////////////////////死亡/////////////////void dead(){ if(sx[0]&gt;39||sx[0]&lt;1||sy[0]&lt;1||sy[0]&gt;23) { alive=false; } for(int i=1;i&lt;length;i++) { if(sx[0]==sx[i]&amp;&amp;sy[0]==sy[i]) { alive=false; } }}///////////////////////////////////// ////////////////菜单///////////////////int menu(){ setXY(50,5); cout&lt;&lt;\" 贪吃蛇游戏\"&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl; setXY(50,10); cout&lt;&lt;\" 普通模式\"&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl; setXY(50,15); cout&lt;&lt;\" 困难模式\"&lt;&lt;endl; setXY(15,25); cout&lt;&lt;\"w s上下选择 回车 确认选择\"; setXY(30,10); while(kbhit()) { HideCursor(0); QWQ=getch(); if(QWQ==Up) { setXY(30,15); cout&lt;&lt;\" \"; setXY(30,10); cout&lt;&lt;\"---------&gt;&gt;&gt;\"; x=30; y=10; } else if(QWQ==Down) { setXY(30,10); cout&lt;&lt;\" \"; setXY(30,15); cout&lt;&lt;\"---------&gt;&gt;&gt;\"; x=30; y=15; } else if(QWQ==13) { if(y==10) return 1; if(y==15) return 2; } }} /////////////////////////////////////int main(){ int mm=1; HideCursor(0); x=30;y=10; setXY(30,10); cout&lt;&lt;\"---------&gt;&gt;&gt;\"; while(QWQ!=13) { Sleep(200); mm=menu(); } system(\"cls\");//清屏函数 setXY(5,5); if(mm==1) QAQ=200; else if(mm==2) QAQ=170-length*2; color(3); HideCursor(0); alive=true; srand(time(NULL)); Interface_Design(); //界面设计 sx[0]=5; sy[0]=5; sx[1]=4; sy[1]=5; snake(); key=Right; direction=0; while(1) { color(6); if(!f)food(); color(2); Sleep(QAQ); if(kbhit()) { if((key=getch())==-32) key=getch(); } if(key==Up&amp;&amp;direction==Down) key=Down; else if(key==Down&amp;&amp;direction==Up) key=Up; else if(key==Right&amp;&amp;direction==Left) key=Left; else if(key==Left&amp;&amp;direction==Right) key=Right; Control_Direction(); dead(); if(!alive) break; setXY(50,25); cout&lt;&lt;\"得分:\"&lt;&lt;(length-2)*2&lt;&lt;endl; } color(7); system(\"cls\");//清屏函数 cout&lt;&lt;\"GAME OVER\"&lt;&lt;endl; cout&lt;&lt;\"得分:\"&lt;&lt;(length-2)*2&lt;&lt;endl; system(\"pause\");return 0; } 这里我还加了颜色改变和主菜单，也十分简单，使用坐标函数即可。 如果想要显示最高分的话我想的是使用文件那一块的知识。","link":"/2019/07/23/Snake/"},{"title":"HELLO WORLD","text":"HELLO WORLD1234567#include&lt;iostream&gt;using namespace std;int main(){ cout&lt;&lt;\"HELLO WORLD\"; return 0;}","link":"/2019/07/11/first/"},{"title":"List","text":"双链表1.为什么要用链表大家在存储多组数据时，会选用数组，但在数组中间删减或是增加数据时，需要将整个数组往前后“平移”。 增加： 12345678void Add(int value, int index, int size){ for(int i = index, i &lt;= size; i++) { a[i+1] = a[i]; } a[index] = value;} 删减： 1234567void Delete(int v, int size){ for(int i = index, i &lt;= size; i++) { a[i] = a[i+1]; }} 这样的时间复杂度会很高，也十分麻烦，需要遍历一遍才能完成操作，而链表可以之前在中间插入、删除。 2.双链表模型一般来说，链表有“head”与“tail”，头与尾的中间用来存储数据，每个节点都有两个指针，指向节点的前后。 next：后指针，代表这个节点的下一个节点。 pre：前指针，代表这个节点的上一个节点。 3.创建双链表需要一个data数据、前指针和后指针，我们使用结构体将它们封装起来。 123456struct list{ int value;//数据 list *next;//后指针 list *pre;//前指针};//链表结构体 4.初始化我们已经创建好了一个链表，那么需要对它进行初始化操作，书写初始化函数。 我们需要为head和tail开一个新的空间，否则将成为一个没空间没内存的“野指针”。 12345678910void initialization(list *&amp;head, list *&amp;tail)//传入头指针与尾指针{ head = new list (); tail = new list (); //为head、tail开空间 head -&gt; next = tail;//head的\"next\"指向tail head -&gt; pre = NULL;//head的\"pre\"指向NULL(空) tail -&gt; pre = head;//tail的\"next\"指向tail tail -&gt; next = NULL;//tail的\"next\"指向NULL(空)}//初始化 5.插入、删除那么链表的插入、删除是怎样实现的呢？ 插入我们想将一个new data插入data之后，我们需要将data的“next”指针指向new data，Tail的“pre”指针指向new data，new data的“next”指针指向TAIL、“pre”指针指向data。 1234567891011void insert(list *&amp;tail, int v){ list *p = new list (); list *q = new list (); q = tail -&gt; pre; p -&gt; value = v; p -&gt; next = tail; tail -&gt; pre = p; p -&gt; pre = q; q -&gt; next = p;}//添加 删除若想将data删掉，我们需要将HAED的“next”指针指向TAIL，TAIL的“pre”指针指向HEAD。 123456789101112131415void Delete(list *&amp;head, int v){ list *p = head; p = p -&gt; next; while(p -&gt; next != NULL) { if(p -&gt; value == v) { p -&gt; next -&gt; pre = p -&gt; pre; p -&gt; pre -&gt; next = p -&gt; next; break; } p = p -&gt; next; }}//删除 6.打印若想将链表中的数据打印出来，需要从head开始向后循环，”head-&gt;value“代表head节点指向的数据，每打印一个数据后，将head替换为”head-&gt;next“,也就是head现在指向的是head的下一个，直到head为空时，也就是head打印最后一个数据后，结束打印。 1234567891011void print(list *head){ cout &lt;&lt; \"开始打印\" &lt;&lt; endl; head = head -&gt; next; while(head -&gt; next != NULL) { cout &lt;&lt; head -&gt; value &lt;&lt; endl; head = head -&gt; next; } cout &lt;&lt; \"结束打印\" &lt;&lt; endl; }//打印 7.清空删除每一个节点指针，循环下去。需要注意的是，我们需要创建一个新的指针来存储删除前指针的下一个指针，这是因为节点被删除后就不具备指向下一个的作用了，会导致找不到节点而出现很多问题。 1234567891011121314void Empty(list *head){ list *p = new list (); list *HEAD = head; HEAD = HEAD -&gt; next; while(HEAD -&gt; next != NULL) { p = HEAD -&gt; next; HEAD -&gt; next -&gt; pre = HEAD -&gt; pre; HEAD -&gt; pre -&gt; next = HEAD -&gt; next; delete HEAD; HEAD = p; }}//清空 8.完整代码网上很多代码都写了“typedef”，身边一些同学也这么写过，据了解后发现“typedef”在c语言书写时会较轻松。因为c语言在定义一个指针时不能直接“list xxx”，而需要“struct list xxx”。 传参时是否加“&amp;”，是根据你的功能是否需要修改链表的头指针的值，若不改变使用“*”即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;using namespace std;struct list{ int value;//数值 list *next;//下一个 list *pre;//上一个 };//链表结构体 int x;void initialization(list *&amp;head, list *&amp;tail){ head = new list (); tail = new list (); head -&gt; next = tail; head -&gt; pre = NULL; tail -&gt; pre = head; tail -&gt; next = NULL;}//初始化 void insert(list *&amp;tail, int v){ list *p = new list (); list *q = new list (); q = tail -&gt; pre; p -&gt; value = v; p -&gt; next = tail; tail -&gt; pre = p; p -&gt; pre = q; q -&gt; next = p;}//添加 void Empty(list *&amp;head){ list *p = new list (); list *HEAD = head; HEAD = HEAD -&gt; next; while(HEAD -&gt; next != NULL) { p = HEAD -&gt; next; HEAD -&gt; next -&gt; pre = HEAD -&gt; pre; HEAD -&gt; pre -&gt; next = HEAD -&gt; next; delete HEAD; HEAD = p; } }//清空void Delete(list *&amp;head, int v){ list *p = head; p = p -&gt; next; while(p -&gt; next != NULL) { if(p -&gt; value == v) { p -&gt; next -&gt; pre = p -&gt; pre; p -&gt; pre -&gt; next = p -&gt; next; break; } p = p -&gt; next; }}//删除void print(list *head){ cout &lt;&lt; \"开始打印\" &lt;&lt; endl; head = head -&gt; next; while(head -&gt; next != NULL) { cout &lt;&lt; head -&gt; value &lt;&lt; endl; head = head -&gt; next; } cout &lt;&lt; \"结束打印\" &lt;&lt; endl; }//打印 int main(){ list *head, *tail; initialization(head, tail); while(1) { cout &lt;&lt; \"1.insert\" &lt;&lt; endl &lt;&lt; \"2.Empty\" &lt;&lt; endl &lt;&lt; \"3.print\" &lt;&lt; endl &lt;&lt; \"4.Delete\" &lt;&lt; endl &lt;&lt; \"5.EXIT\" &lt;&lt; endl; cin &gt;&gt; x; switch(x) { case 1: cin &gt;&gt; x; insert(tail, x); break; case 2: Empty(head); break; case 3: print(head); break; case 4: cin &gt;&gt; x; Delete(head, x); break; case 5: return 0; } } return 0;}","link":"/2019/11/03/List/"}],"tags":[{"name":"game","slug":"game","link":"/tags/game/"},{"name":"daily","slug":"daily","link":"/tags/daily/"},{"name":"data structure","slug":"data-structure","link":"/tags/data-structure/"}],"categories":[{"name":"code","slug":"code","link":"/categories/code/"}]}