{"pages":[{"title":"","text":"一只兔子","link":"/about/index.html"}],"posts":[{"title":"HELLO WORLD","text":"1234567#include&lt;iostream&gt;using namespace std;int main(){ cout&lt;&lt;\"HELLO WORLD\"; return 0;}","link":"/2019/07/11/first/"},{"title":"Merge Sort / Quickly Sort / Shell Sort","text":"这次我们介绍三种排序手写方法：Merge Sort、Quickly Sort 、Shell Sort. 本文排序都使用的字符串组。 Merge SortMerge Sort 也称为归并排序，算法如下： 归并排序是将两个已经处理好的上升序列整合在一起成为一个新的上升序列。 算法：将两个序列从左到右依次对比比较，分别设定两个序列的头尾指向，对比此时下标两个序列相对应的数字，小的则放入整合序列中，更新下标，若相等，则任意一个放入整合序列中，若其中一个序列已经放完，则按照顺序将另一个序列全部放入整合序列中。 1234567891011121314//s1、s2为两个上升序列，s3为整合序列//l1、r1，l2、r2,分别为两个上升序列的头尾下标void Merge_Sort(string *&amp;s1, int l1, int r1, string *&amp;s2, int l2, int r2, string *&amp;s3){ int i1 = l1, i2 = l2; int len = 0;//整合序列的长度 while(i1 &lt;= r1 &amp;&amp; i2 &lt;= r2) { if(s1[i1] &gt;= s2[i2]) s3[++len] = s2[i2++]; else s3[++len] = s1[i1++]; } for(int i = i1; i &lt;= r1; i++) s3[++len] = s1[i]; for(int i = i2; i &lt;= r2; i++) s3[++len] = s2[i];} Quickly SortQuickly Sort也就是头文件algorithm中的内置sort函数，而且它真的很快！ 那么为什么要学习手写呢？因为在一些比赛或考试中不能使用内置函数sort，只能手写。 算法：从数列中取出一个基准数，然后以此为基准，比基准数大的数字都放在它的右边，将比基准数小的数都放在它的左边，然后对左右子区间采用相同的方法，直到每个区间只有一个数。 12345678910111213141516void Sort(string *&amp;a,int l, int r){ string x = a[l];//取出一个数 int i = l, j = r;//左右下标 if(l &gt;= r) return ; while(i &lt; j) { while(i &lt; j &amp;&amp; x &lt;= a[j]) j--;//从右到左找到一个小于x的 if(i &lt; j) a[i++] = a[j]; while(i &lt; j &amp;&amp; a[i] &lt;= x) i++;//从左到右找到一个大于x的 if(i &lt; j) a[j--] = a[i]; } a[i] = x;//将它放中间 Sort(a, l, i - 1); Sort(a, i + 1, r);} Shell SortShell Sort又叫希尔排序，是一种排序演化而成的排序方式。 算法：开始时：将序列区分为n/2个间隔，将相同间隔的数进行排序，减小间隔数，按照以上操作继续排序，直到间隔为1停止。 1234567891011121314151617void Shellsort(int a[], int n){ int tmp, i, j; for(int Increment = n / 2; Increment &gt; 0; Increment /= 2) { for(i = Increment; i &lt; n; i++) { tmp = a[i]; for(j = i; j &gt;= Increment; j -= Increment) { if(tmp &lt; a[j - Increment]) a[j] = a[j - Increment]; else break; } a[j] = tmp; } }}","link":"/2019/12/10/Sort/"},{"title":"How to configure the Java compilation environment","text":"1.下载JDK官方下载网页：https://www.oracle.com/index.html 进入网页后在框中输入“java” 选择“Java Download Central“ 进入版本下载页面，选择自己需要的版本进行下载。点击”JDK Download“。 2.安装JDK打开下载好的安装包，选择存储空间大的硬盘安装。 这里就不进行赘述了。 3.配置环境打开下载好的jdk文件夹(如图) ****：如果是13版本则没有‘jre’文件，那么我需要进行如下操作，否则可跳过“”步骤： 在此删除地址，输入”cmd“回车 得到如下图： 在这里输入”bin\\jlink.exe –module-path jmods –add-modules java.desktop –output jre“后回车即可 再回到jdk文件夹会看到生成的”jre“文件夹 在控制面版中打开“编辑系统环境变量” 上方项目选择“高级”，点击“环境变量” 进入页面后我们的操作全再下方进行 (1)新建：变量名为”JAVA_HOME”,变量值为”E:\\Java\\jdk-13.0.2“ (jdk的安装路径) (2)编辑：原有的变量”Path“，在原变量值的最后面加上”%JAVA_HOME%\\bin“ 与 ”%JAVA_HOME%\\jre\\bin“ (3)新建：变量名为”CLASSPATH”,变量值为 ”.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar“ （配置完成后千万别忘记点确定哦=w=） 在下方搜索“cmd” 打开后输入”java”得到如下反聩 输入“javac”得到如下反馈 配置环境成功！ eclipse官网地址：https://www.eclipse.org/","link":"/2020/03/05/How to configure the Java compilation environment/"},{"title":"Binary Tree Calculator","text":"1.基本思路​ Binary tree calculator也就是使用二叉树实现计算器的功能，相信大家以前都使用栈实现过计算器功的能，使用两个栈分别存数字与字符，一边计算一边“pop”、“push”，或是先将输入的中缀表达式转为后缀表达式，之后运算。而我们的Binary tree calculator则也需要用到栈，先将中缀表达式转为后缀表达式，之后使用指针栈构建Expression tree，再利用二叉树节点之间的关系递推遍历计算即可。 2.中缀表达式转后缀表达式那么怎么才能将中缀表达式转为后缀表达式呢？我们来看下面一个例子。 ​ a+b*(c-d)/e 上述则为一个中缀表达式，它的后缀表达式如下： ​ abcd-*e/+ 我们利用栈来实现这个过程： (1)若遇到数字直接输出。 (2)若遇到字符(‘+’、’-‘、’*’、’/‘),对比栈顶元素的优先级，如果比栈顶元素优先级高，则直接入栈，否则将栈中元素不断出栈，直到出现优先级比存入字符低，则将字符入栈。 (3)若字符为’(‘,则直接入栈，若遇到‘)’，则将‘(’前的元素弹出。 (4)若扫描完成后栈中还有元素滞留，则将栈中元素全部弹出。 为了使得大家清晰可见看懂，实现过程的图片每一步兔子都将它画了出来，所以图片有一点多…… 3.构建Expression tree我们将每一个数或符号都看做一个节点，在此基础上构建Expression tree。 创建一个指针栈，遍历后缀表达式，若遇到数字则作为一个节点存入指针栈，若遇到符号则取出栈中两个节点作为此节点的左右儿子，再将节点存入栈中，以此类推。当后缀表达式被完全遍历后，栈中将只存在一个节点指针，此指针则为树的根节点。 4.计算Expression tree我们已经建立好了Expression tree，现在我们只需要计算出值就可以完成我们的Binary tree calculator了！ 那么…..要怎么计算呢？ 兔子思考了一下，发现可以使用递归的方法计算答案！ 我们从树的根节点开始从上往下遍历，每遇到一个符号则在使用此函数返回与符号相符的运算式，直到遇到数字则返回数字本身的值。 例如，根节点为‘+’，则return 计算'+'的左节点的值 + 计算'+'右节点的值，而为了得到左右节点的值，函数会继续运算，当遇到‘+’的左儿子则return a，当遇到右儿子‘/’则会继续返回左右儿子的计算值return计算'/'的左节点的值 / 计算'/'右节点的值,而为了得到左右节点的值，函数会继续运算，当遇到左儿子‘*’则会继续返回左右儿子的计算值return计算 * 的左节点的值 * 计算 * 右节点的值,而为了得到左右节点的值，函数会继续运算，当遇到 * 的左儿子则return b，当遇到右儿子‘-’则会继续返回左右儿子的计算值return计算'-'的左节点的值 - 计算'-'右节点的值,而为了得到左右节点的值，函数会继续运算，当遇到‘-’的左儿子则return c，当遇到右儿子则 return d,当遇到‘/’的右儿子则return e. 经历了层层的递归返回，我们将得到最终表达式答案！ 5.完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;cmath&gt;using namespace std;double QAQ(string pe){ double num1=0; double num2=0; int size = 0; int f = 1; for(int i = 0; i &lt; pe.length(); i++) { if(pe[i] == '.') { f = 0; continue; } if(f) num1 = num1 * 10 + pe[i] - '0'; else { num2 = num2 * 10 + pe[i] - '0'; size ++; } } return (num1 + num2 / pow(10,size)); }void ppe(string ix,string &amp;pe)//中缀转后缀 { stack&lt;char&gt; QWQ; for(int i = 0; i &lt; ix.length(); i++) { if((ix[i] &lt;= '9' &amp;&amp; ix[i] &gt;= '0') || ix[i] == '.') { while((ix[i] &lt;= '9' &amp;&amp; ix[i] &gt;= '0') || ix[i] == '.') { pe += ix[i]; i++; } pe +=' '; i--; }//数字直接放 else if((ix[i] == '+' || ix[i] == '-')) { if(QWQ.empty() || QWQ.top() == '(') { QWQ.push(ix[i]); } else { while(!QWQ.empty()) { if(QWQ.top() == '(') break; pe += QWQ.top(); QWQ.pop(); } QWQ.push(ix[i]); } } else if((ix[i] == '*' || ix[i] == '/')) { if(QWQ.empty() || QWQ.top() == '+' || QWQ.top() == '-') { QWQ.push(ix[i]); } else { while(!QWQ.empty()) { if(QWQ.top() == '+'|| QWQ.top() == '-'|| QWQ.top() == '(') break; pe += QWQ.top(); QWQ.pop(); } QWQ.push(ix[i]); } } else if(ix[i] == '(') { QWQ.push(ix[i]); } else if(ix[i] == ')') { while(QWQ.top() != '(') { pe += QWQ.top(); QWQ.pop(); } QWQ.pop(); } } while(!QWQ.empty()) { pe += QWQ.top(); QWQ.pop(); } cout &lt;&lt; pe &lt;&lt; endl; }struct tree{ string data; tree *left; tree *right;};//一棵树 void insert(string value,stack&lt;tree *&gt; &amp;ss,int flag)// { tree *t = new tree(); t -&gt; data = value; t -&gt; left = NULL; t -&gt; right = NULL; if(!ss.empty() &amp;&amp; flag) { tree *p1 = ss.top(); ss.pop(); tree *p2 = ss.top(); ss.pop(); t -&gt; left = p2; t -&gt; right = p1; } ss.push(t);} tree *creat_tree(string pe,stack&lt;tree *&gt; &amp;ss)//建立表达式树 { for(int i = 0; i &lt; pe.length(); i++) { string num_ex = \"\"; string ch_ex = \"\"; if((pe[i] &lt;= '9' &amp;&amp; pe[i] &gt;= '0') || pe[i] == '.') { while(pe[i] != ' ') { num_ex += pe[i]; i++; } insert(num_ex, ss,0); } else { ch_ex += pe[i]; insert(ch_ex, ss,1); } } tree *tmp = ss.top(); return ss.top();}double Calculator(tree *t)//计算器 { if(t -&gt; data == \"+\") return Calculator(t -&gt; left) + Calculator(t -&gt; right); else if(t -&gt; data == \"-\") return Calculator(t -&gt; left) - Calculator(t -&gt; right); else if(t -&gt; data == \"*\") return Calculator(t -&gt; left) * Calculator(t -&gt; right); else if(t -&gt; data == \"/\") return Calculator(t -&gt; left) / Calculator(t -&gt; right); else return QAQ(t -&gt; data);} int main(){ string ix; string pe; stack&lt;tree *&gt; ss;//指针栈 cin &gt;&gt; ix; ppe(ix,pe); cout &lt;&lt; Calculator(creat_tree(pe,ss)) &lt;&lt; endl; return 0;}","link":"/2019/11/17/tree/"},{"title":"Double Linked List","text":"1.为什么要用链表大家在存储多组数据时，会选用数组，但在数组中间删减或是增加数据时，需要将整个数组往前后“平移”。 增加： 12345678void Add(int value, int index, int size){ for(int i = index, i &lt;= size; i++) { a[i+1] = a[i]; } a[index] = value;} 删减： 1234567void Delete(int v, int size){ for(int i = index, i &lt;= size; i++) { a[i] = a[i+1]; }} 这样的时间复杂度会很高，也十分麻烦，需要遍历一遍才能完成操作，而链表可以之前在中间插入、删除。 2.双链表模型一般来说，链表有“head”与“tail”，头与尾的中间用来存储数据，每个节点都有两个指针，指向节点的前后。 next：后指针，代表这个节点的下一个节点。 pre：前指针，代表这个节点的上一个节点。 3.创建双链表需要一个data数据、前指针和后指针，我们使用结构体将它们封装起来。 123456struct list{ int value;//数据 list *next;//后指针 list *pre;//前指针};//链表结构体 4.初始化我们已经创建好了一个链表，那么需要对它进行初始化操作，书写初始化函数。 我们需要为head和tail开一个新的空间，否则将成为一个没空间没内存的“野指针”。 12345678910void initialization(list *&amp;head, list *&amp;tail)//传入头指针与尾指针{ head = new list (); tail = new list (); //为head、tail开空间 head -&gt; next = tail;//head的\"next\"指向tail head -&gt; pre = NULL;//head的\"pre\"指向NULL(空) tail -&gt; pre = head;//tail的\"next\"指向tail tail -&gt; next = NULL;//tail的\"next\"指向NULL(空)}//初始化 5.插入、删除那么链表的插入、删除是怎样实现的呢？ 插入我们想将一个new data插入data之后，我们需要将data的“next”指针指向new data，Tail的“pre”指针指向new data，new data的“next”指针指向TAIL、“pre”指针指向data。 1234567891011void insert(list *&amp;tail, int v){ list *p = new list (); list *q = new list (); q = tail -&gt; pre; p -&gt; value = v; p -&gt; next = tail; tail -&gt; pre = p; p -&gt; pre = q; q -&gt; next = p;}//添加 删除若想将data删掉，我们需要将HAED的“next”指针指向TAIL，TAIL的“pre”指针指向HEAD。 123456789101112131415void Delete(list *&amp;head, int v){ list *p = head; p = p -&gt; next; while(p -&gt; next != NULL) { if(p -&gt; value == v) { p -&gt; next -&gt; pre = p -&gt; pre; p -&gt; pre -&gt; next = p -&gt; next; break; } p = p -&gt; next; }}//删除 6.打印若想将链表中的数据打印出来，需要从head开始向后循环，”head-&gt;value“代表head节点指向的数据，每打印一个数据后，将head替换为”head-&gt;next“,也就是head现在指向的是head的下一个，直到head为空时，也就是head打印最后一个数据后，结束打印。 1234567891011void print(list *head){ cout &lt;&lt; \"开始打印\" &lt;&lt; endl; head = head -&gt; next; while(head -&gt; next != NULL) { cout &lt;&lt; head -&gt; value &lt;&lt; endl; head = head -&gt; next; } cout &lt;&lt; \"结束打印\" &lt;&lt; endl; }//打印 7.清空删除每一个节点指针，循环下去。需要注意的是，我们需要创建一个新的指针来存储删除前指针的下一个指针，这是因为节点被删除后就不具备指向下一个的作用了，会导致找不到节点而出现很多问题。 1234567891011121314void Empty(list *head){ list *p = new list (); list *HEAD = head; HEAD = HEAD -&gt; next; while(HEAD -&gt; next != NULL) { p = HEAD -&gt; next; HEAD -&gt; next -&gt; pre = HEAD -&gt; pre; HEAD -&gt; pre -&gt; next = HEAD -&gt; next; delete HEAD; HEAD = p; }}//清空 8.完整代码网上很多代码都写了“typedef”，身边一些同学也这么写过，据了解后发现“typedef”在c语言书写时会较轻松。因为c语言在定义一个指针时不能直接“list xxx”，而需要“struct list xxx”。 传参时是否加“&amp;”，是根据你的功能是否需要修改链表的头指针的值，若不改变使用“*”即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;using namespace std;struct list{ int value;//数值 list *next;//下一个 list *pre;//上一个 };//链表结构体 int x;void initialization(list *&amp;head, list *&amp;tail){ head = new list (); tail = new list (); head -&gt; next = tail; head -&gt; pre = NULL; tail -&gt; pre = head; tail -&gt; next = NULL;}//初始化 void insert(list *&amp;tail, int v){ list *p = new list (); list *q = new list (); q = tail -&gt; pre; p -&gt; value = v; p -&gt; next = tail; tail -&gt; pre = p; p -&gt; pre = q; q -&gt; next = p;}//添加 void Empty(list *&amp;head){ list *p = new list (); list *HEAD = head; HEAD = HEAD -&gt; next; while(HEAD -&gt; next != NULL) { p = HEAD -&gt; next; HEAD -&gt; next -&gt; pre = HEAD -&gt; pre; HEAD -&gt; pre -&gt; next = HEAD -&gt; next; delete HEAD; HEAD = p; } }//清空void Delete(list *&amp;head, int v){ list *p = head; p = p -&gt; next; while(p -&gt; next != NULL) { if(p -&gt; value == v) { p -&gt; next -&gt; pre = p -&gt; pre; p -&gt; pre -&gt; next = p -&gt; next; break; } p = p -&gt; next; }}//删除void print(list *head){ cout &lt;&lt; \"开始打印\" &lt;&lt; endl; head = head -&gt; next; while(head -&gt; next != NULL) { cout &lt;&lt; head -&gt; value &lt;&lt; endl; head = head -&gt; next; } cout &lt;&lt; \"结束打印\" &lt;&lt; endl; }//打印 int main(){ list *head, *tail; initialization(head, tail); while(1) { cout &lt;&lt; \"1.insert\" &lt;&lt; endl &lt;&lt; \"2.Empty\" &lt;&lt; endl &lt;&lt; \"3.print\" &lt;&lt; endl &lt;&lt; \"4.Delete\" &lt;&lt; endl &lt;&lt; \"5.EXIT\" &lt;&lt; endl; cin &gt;&gt; x; switch(x) { case 1: cin &gt;&gt; x; insert(tail, x); break; case 2: Empty(head); break; case 3: print(head); break; case 4: cin &gt;&gt; x; Delete(head, x); break; case 5: return 0; } } return 0;}","link":"/2019/11/03/List/"},{"title":"Snake","text":"学年设计的时候做的贪吃蛇，只是简单的做出来基本操作，写的代码从时间和空间上看都不是很优。 这里讲一下大概思路： 一条蛇不停的移动， 玩家将控制蛇的方向，蛇在吃掉食物后，将会重新生成食物，若蛇吃到自己的身体或撞到边框则结束游戏并显示得分。 一个最简贪吃蛇游戏需要3个部分： 1.地图 2.蛇移动 3.食物 地图地图使用了坐标函数设置，画一个框 移动贪吃蛇的移动分为按键控制与在未有按键输入时向原方向移动。 按键控制使用kbhit()函数接受即可设置蛇的移动。 在未出现按键输入时，蛇将不停的向原方向移动(将每个蛇的坐标向前覆盖并清除最后一个坐标)，还需要使用sleep()函数与循环。 sleep()函数可以在一定时间让蛇停下来(不然刚开局就死掉了)。 食物食物需要在蛇吃掉后随机生成，且不能生成在蛇的身上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296#include&lt;iostream&gt;#include &lt;windows.h&gt; #include&lt;ctime&gt;#include&lt;queue&gt;#include&lt;conio.h&gt;//内含有kbhit()函数 在VC里面有这个头文件#define Up 119//72 #define Down 115 //80 #define Left 97 //75#define Right 100 //77#define Enter 13//上，下，左，右//system(\"cls\");//清屏函数 using namespace std;//////////全局变量////////////HANDLE hOut,hIn,hwnd;bool alive;//是否存活int grade=0;//得分char key;char direction;//方向bool kk=false;int length=2;//初始长度bool f=false;//是否已经生成食物int sx[100];//snake横坐标int sy[100];//snake纵坐标int food_x;//food横坐标int food_y;//food纵坐标int x,y,QAQ;char QWQ;///////////////////////////////void HideCursor(int n) /*隐藏光标*/{ CONSOLE_CURSOR_INFO cursor_info={1,n}; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE),&amp;cursor_info);}//////////////颜色函数/////////////////int color(int c){ hOut=GetStdHandle(STD_OUTPUT_HANDLE);//获取字符输出句柄 SetConsoleTextAttribute(hOut,c);//改变颜色 return 0; } void setXY(int x,int y) //移动坐标{ COORD coord; coord.X=x; coord.Y=y; SetConsoleCursorPosition( GetStdHandle( STD_OUTPUT_HANDLE ), coord );}///////////////////////////////////// ////////////画图///////////////////void Interface_Design(){ for(int i=0;i&lt;24;i++) { setXY(0,i); cout&lt;&lt;\"#\"; setXY(40,i); cout&lt;&lt;\"#\"; } for(int i=0;i&lt;=40;i++) { setXY(i,0); cout&lt;&lt;\"#\"; setXY(i,24); cout&lt;&lt;\"#\"; } setXY(50,20); cout&lt;&lt;\"操作\"; setXY(50,22); cout&lt;&lt;\"w s a d 控制上下左右\";}/////////////////////////////////////////////////画蛇//////////////////// void snake(){ for(int i=0;i&lt;length;i++) { setXY(sx[i],sy[i]); if(i==0) cout&lt;&lt;\"@\"; else cout&lt;&lt;\"*\"; }}void xY(){ for(int i=length-1;i&gt;=1;i--) { sx[i]=sx[i-1]; sy[i]=sy[i-1]; }}//坐标移动 ///////////////////////////////////////// void food() { int x,y; srand((unsigned int)time(NULL)); int ww=1; while(ww) { for(int i=0;i&lt;20;i++) { x=rand()%(20-4)+2; y=rand()%(20-2)+1; } for(int i=0;i&lt;length;i++) { ww=0; if(sx[i]==x&amp;&amp;sy[i]==y) { ww=1; break; } }//不能再蛇的身体上生成食物 } setXY(x,y); food_x=x; food_y=y; cout&lt;&lt;'$'; f=true;}//食物生成函数 void L(){ if(sx[0]==food_x&amp;&amp;sy[0]==food_y) { f=false; length++; sx[length-1]=sx[length-2]; sy[length-1]=sy[length-2]; }}//对蛇是否吃掉食物进行判定，并增加蛇的长度////////////方向控制 ////////////////void Control_Direction(){ switch(key) { case Up: direction=Up; L(); setXY(sx[length-1],sy[length-1]); cout&lt;&lt;\" \";xY(); sy[0]--; setXY(sx[0],sy[0]); snake(); break; case Down:direction=Down; L(); setXY(sx[length-1],sy[length-1]); cout&lt;&lt;\" \"; xY(); sy[0]++; setXY(sx[0],sy[0]); snake(); break; case Left:direction=Left; L(); setXY(sx[length-1],sy[length-1]); cout&lt;&lt;\" \";xY(); sx[0]--; setXY(sx[0],sy[0]); snake(); break; case Right:direction=Right; L(); setXY(sx[length-1],sy[length-1]); cout&lt;&lt;\" \";xY(); sx[0]++; setXY(sx[0],sy[0]); snake(); break; }} //////////////////////////////////////////////////////死亡/////////////////void dead(){ if(sx[0]&gt;39||sx[0]&lt;1||sy[0]&lt;1||sy[0]&gt;23) { alive=false; } for(int i=1;i&lt;length;i++) { if(sx[0]==sx[i]&amp;&amp;sy[0]==sy[i]) { alive=false; } }}///////////////////////////////////// ////////////////菜单///////////////////int menu(){ setXY(50,5); cout&lt;&lt;\" 贪吃蛇游戏\"&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl; setXY(50,10); cout&lt;&lt;\" 普通模式\"&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl; setXY(50,15); cout&lt;&lt;\" 困难模式\"&lt;&lt;endl; setXY(15,25); cout&lt;&lt;\"w s上下选择 回车 确认选择\"; setXY(30,10); while(kbhit()) { HideCursor(0); QWQ=getch(); if(QWQ==Up) { setXY(30,15); cout&lt;&lt;\" \"; setXY(30,10); cout&lt;&lt;\"---------&gt;&gt;&gt;\"; x=30; y=10; } else if(QWQ==Down) { setXY(30,10); cout&lt;&lt;\" \"; setXY(30,15); cout&lt;&lt;\"---------&gt;&gt;&gt;\"; x=30; y=15; } else if(QWQ==13) { if(y==10) return 1; if(y==15) return 2; } }} /////////////////////////////////////int main(){ int mm=1; HideCursor(0); x=30;y=10; setXY(30,10); cout&lt;&lt;\"---------&gt;&gt;&gt;\"; while(QWQ!=13) { Sleep(200); mm=menu(); } system(\"cls\");//清屏函数 setXY(5,5); if(mm==1) QAQ=200; else if(mm==2) QAQ=170-length*2; color(3); HideCursor(0); alive=true; srand(time(NULL)); Interface_Design(); //界面设计 sx[0]=5; sy[0]=5; sx[1]=4; sy[1]=5; snake(); key=Right; direction=0; while(1) { color(6); if(!f)food(); color(2); Sleep(QAQ); if(kbhit()) { if((key=getch())==-32) key=getch(); } if(key==Up&amp;&amp;direction==Down) key=Down; else if(key==Down&amp;&amp;direction==Up) key=Up; else if(key==Right&amp;&amp;direction==Left) key=Left; else if(key==Left&amp;&amp;direction==Right) key=Right; Control_Direction(); dead(); if(!alive) break; setXY(50,25); cout&lt;&lt;\"得分:\"&lt;&lt;(length-2)*2&lt;&lt;endl; } color(7); system(\"cls\");//清屏函数 cout&lt;&lt;\"GAME OVER\"&lt;&lt;endl; cout&lt;&lt;\"得分:\"&lt;&lt;(length-2)*2&lt;&lt;endl; system(\"pause\");return 0; } 这里我还加了颜色改变和主菜单，也十分简单，使用坐标函数即可。 如果想要显示最高分的话我想的是使用文件那一块的知识。","link":"/2019/07/23/Snake/"},{"title":"How to configure the Java Web compilation environment","text":"一.安装JDK(配置环境变量)配置java环境中已有详细介绍，这里将不做赘述。 传送门链接: https://xiaotufly.github.io/2020/03/05/How%20to%20configure%20the%20JAVA%20compilation%20environment/ 二.安装 elipse Java EE这里建立在已经装配elipse 的情况下。 1.打开elipse-&gt;Help-&gt;About Eclipse IDE （查看版本号） 可得到版本号: 2019-12（每个人版本号不同） 2.打开elipse-&gt;Help-&gt;Install New Software在Work with中输入 ‘版本号 + http://download.eclipse.org/releases/ + 版本号’ 找到Web，XML，Jave EE ……..这一栏勾选后并一直选择Next，等候下载完成即可。 三.安装Tomcat安装包云盘链接： 链接：https://pan.baidu.com/s/1Nmfk7zWcpduSTbhMy-RoCg提取码：ipcp 1.打开安装包 2.一直点Next直到出现选择jdk安装目录 3.一直点Next直到出现选择jdk安装目录 4.安装完成后在浏览器在地址栏输入localhost:8080,出现以下界面代表安装配置成功 四.将Tomacat放入elipse1.elipse -&gt; window -&gt; preferences -&gt; Server -&gt;Runtime Environments 2.点击Add，找到9.0版本并选择，点击Next 3.点击Browse，选择tomcat路径，Finish后点击OK即可。 ### 五.运行程序 123456789101112&lt;% page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;うさぎかっこいい&lt;/body&gt;&lt;/html&gt; 1.运行程序 2.运行结果","link":"/2020/09/14/How to configure the Java Web compilation environment/"},{"title":"Python","text":"一.基础语法注意:python使用时需要严格缩进，否则在执行是会出现报错 1.注释1# 这里是一个注释嗷！ 2.打印1print ('hello word!') 3. if &amp; else12345678if 判断条件: print ('true')else 判断条件: .......else 判断条件: .......else: ....... 4.循环1234567891011while 判断条件 : ...........# while 循环for num in range(a,b):# 循环a -- b 之间的数字 ............# for 循环pass# pass 一般不做任何事情 做站位语句# 其他循环中还会使用continue,break，常见的语法不加以解释 5.类型python中的数据类型不允许改变，可以删除对象，重新分配空间。 12num = 1del num # 删除变量num 字符串创建 1s = 'a string' python 的索引可以为负数，反向索引，从右边开始计算 12s[-1] # 'g's[-2] # 'n' 一些常用函数 1234567891011121314len(s) # 字符串长度upper() # 全部大写lower() # 全部小写swapcase() # 大小写互换capitalize() # 首字母大写，其余小写title() # 首字母大写ljust(width) # 获取固定长度，左对齐，右边不够用空格补齐rjust(width) # 获取固定长度，右对齐，左边不够用空格补齐center(width) # 获取固定长度，中间对齐，两边不够用空格补齐zfill(width) # 获取固定长度，右对齐，左边不足用0补齐find() # 搜索指定字符串，没有返回-1index() # 同上，但是找不到会报错rfind() # 从右边开始查找count() # 统计指定的字符串出现的次数 不可变性 无法在特定位置修改值，修改会清理旧的对象。 python中的核心类型，数字、字符串以及元祖是不可变的，而字典与列表可完全自由改变。 12s = 'w' + s[1:] # 'w string's[0] = 'a' #报错代码 列表列表没有固定类型的约束，用中括号表示，组成对象是有序的，组成的各个对象允许不同。 创建 12list1 = []list2 = ['QWQ', 'QAQ', 'QVQ', 'QUQ'] 访问 12list2[0] # 'QWQ'list2[1:4] # 'QAQ QVQ' 一些常用函数 1234567891011121314append() # 添加函数cmp(list1, list2) # 比较两个列表的元素len(list) # 列表元素个数max(list) # 返回列表元素最大值min(list) # 返回列表元素最小值list(seq) # 将元组转换为列表count(obj) # 统计某个元素在列表中出现的次数extend(seq) # 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）index(obj) # 从列表中找出某个值第一个匹配项的索引位置insert(index, obj) # 将对象插入列表pop([index=-1]) # 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值remove(obj) # 移除列表中某个值的第一个匹配项reverse() # 反向列表中元素sort(cmp=None, key=None, reverse=False) # 对原列表进行排序 元祖元祖是序列，但是它具有不可变性，与字符串类似，它提供了一种完整性的约束，编写大型程序更为方便。元祖角色类似于其他语言中的“常数”声明，这种常数概念在Python中是与对象相结合，而不是变量。 创建 123t1 = ()t2 = (1,) # 元祖只包含一个元素需要在后面加上逗号t3 = ('QWQ', 'QAQ', 'QVQ', 'QUQ') 访问 1# 与字符串类似 修改 1# 修改元祖的值是非法的，因为不可变性。 一些常用函数 123456cmp(tuple1, tuple2) # 比较两个元组元素。append(value) # 添加元素len(tuple) # 元素个数max(tuple) # 返回元祖最大元素min(tuple) # 返回元祖最小元素tuple(seq) # 将列表转换为元祖 字典字典是另一种可变容器模型，且可存储任意类型对象，用大括号表示，组成对象是无序的，搜索方式是哈希搜索，速度很快。 创建 123d = {key1 : value1, key2 : value2 }d1 = {'QWQ': '123', 'QAQ': '456', 'QVQ': '321', 'QUQ': '654'}d2 = {'QWQ': 123, 321: 456} 访问 1print d1['QWQ'] # 123 添加 1d1['OVO'] = '555' 修改 1d1['QWQ'] = '333' 删除 123del d1['QWQ'] # 删除键是'QWQ'的条目d1.clear() # 清空字典所有条目del d1 # 删除字典 一些常用函数 1234567891011121314151617cmp(dict1, dict2) # 比较两个字典元素len(dict) # 计算字典元素个数，即键的总数str(dict) # 输出字典可打印的字符串表示type(variable) # 返回输入的变量类型，如果变量是字典就返回字典类型clear() # 删除字典内所有元素copy() # 返回一个字典的浅复制fromkeys(seq[, val]) # 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值get(key, default=None) # 返回指定键的值，如果值不在字典中返回default值has_key(key) # 如果键在字典dict里返回true，否则返回falseitems() # 以列表返回可遍历的(键, 值) 元组数组keys() # 以列表返回一个字典所有的键setdefault(key, default=None) # 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为defaultupdate(dict2) # 把字典dict2的键/值对更新到dict里values() # 以列表返回字典中的所有值pop(key[,default]) # 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。popitem() # 返回并删除字典中的最后一对键和值。 6.函数定义规则 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。 定义 1234def functionname( parameters ): \"\"\"comments\"\"\" # 对函数进行一些说明 function_suite return [expression] 7.模块每一个以扩展名py结尾的Python源代码文件都是一个模块，其他文件可以通过导入这个模块来读取这个模块的内容。Python中本来就有很多模块，这里理解为包，需要使用则安装包。 定义模块 首先我们先建立一个新的py文件取名mode 12345print(\"QWQ\")x = 'QUQ'def QAQ(): print(x)# 取名为mode.py 加载模块 python在第一次导入后就将模块名加载到内存，后续的import语句会判断模块是否已被导入，若已导入将仅对加载在内存中的模块对象增加了一次引用，不会重新执行模块语句。 12import mode # mode 为模块名# 导入mode模块后运行后在输出处可以看到“QWQ” 使用模块 12mode.QAQ() # 调用模块中的函数# 运行后结果 “QUQ” 8.文件读文件 12345file = open('text.txt', 'r') # r表示文本文件格式，二进制。 此处为文件打开格式。# 注意，若text.txt文件不存在，则会报错# 我们提前在文件写好内容“读文件成功！”file.read()file.close() # 最后一定要记得关闭文件！ 写文件 123# 发现‘r’模式下不能写文件，只能读文件，尴尬，记得改成'w'file.write('hello word!')file.close() # 最后一定要记得关闭文件！ 二.大数据常用包（只用过部分函数，以后使用了更详细的会更新吧…） 1.pandaspandas使数据预处理、清洗、分析工作变得更快更简单。核心数据结构：Series、DataFrame。 1import pandas as pd Series类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成，即index和values两部分，可以通过索引的方式选取Series中的单个或一组值。 创建 1234567891011121314151617181920a1 = np.arange(5)s1 = pd.Series(a1)print(s1) # 通过标量创建，创建从0--4的长度索引# 输出结果#0 0#1 1#2 2#3 3#4 4a2 = {'1':1,'2':2,'3':3,'a':'hello','b':'python','c':[1,2]}s2 = pd.Series(a2)print(s,type(s2)) # 自定义通过字典创建# 输出结果#1 1#2 2#3 3#a hello#b python#c [1, 2]a3 = 修改 123456789s2['1'] = 'QWQ'print(s2)# 输出结果#1 QWQ#2 2#3 3#a hello#b python#c [1, 2] 删除 1234567891011121314del s2['2']print(s2)# 输出结果# 1 QWQ# 3 3# a hello# b python# c [1, 2]s2 = s2.drop(['b','c'])print(s2)# 输出结果# 1 QWQ# 3 3# a hello 数据查看 .head()方法是查看前几行的数据，默认是5行 .tail()方法是查看后几行的数据，默认也是5行 123456789print(s2.head(2),'\\n')print(s2.tail())# 输出结果# 1 QWQ# 3 3# 1 QWQ# 3 3# a hello DataFrameDataFrame 是一种二维的数据结构，非常接近于电子表格或者类似 mysql 数据库的形式。它的竖行称之为 columns，横行跟前面的 Series 一样，称之为 index，也就是说可以通过 columns 和 index 来确定一个主句的位置。 创建 1234567data = {\"A\":['QWQ','QAQ','QVQ'],\"B\":[100,200,300],\"C\":[1,2,3]}f1 = DataFrame(data)# 输出结果# A B C# 0 QWQ 100 1# 1 QAQ 200 2# 2 QVQ 300 3 常用函数排序 12sort_index # 根据索引来排序sort_values # 根据指定列值排序 统计 1234sum # 值的总和mean # 值的平均数median # 值的算数中位数mad # 根据平均值计算平均绝对离差 去重 1234newdata.drop_duplicates(subset=['A','B','C','D'],keep=False)# 当keep=False时，就是去掉所有的重复行# 当keep=‘first’时，就是保留第一次出现的重复行# 当keep=’last’时就是保留最后一次出现的重复行。 读写文件 123data = pd.read_csv(\"data.txt\")pd.to_csv(\"d:/snp/test.csv\") 2.matplotlib可用于可视化。 1import matplotlib.pyplot as plt 散点图 12345plt.scatter(x, y, marker=None) # x，y为坐标# marker为标记符号#例如plt.scatter(1, 1, marker=None) # 结果如下图 折线图 123x = ['11','12','13','14','15','16','17']y = [58,60,63,71,84,90,10]plt.plot(x,y) # 结果如下图 直方图 12345import numpy as npimport matplotlib.pyplot as pltdata = np.random.randn(10000)plt.hist(data, bins=4, normed=0, facecolor=\"blue\", edgecolor=\"black\", alpha=0.7)# 结果如下图 条形图 1234567from matplotlib import pyplot as pltfrom matplotlib import font_managerb = [56.01, 26.94, 17.53, 16.49, 15.45, 12.96, 11.8, 11.61, 11.28, 11.12, 10.49, 10.3, 8.75, 7.55, 7.32, 6.99, 6.88, 6.86, 6.58, 6.23]plt.figure(figsize=(15,7))plt.bar(range(len(b)),b,width=0.3)# 结果如下图 箱线图 1234from matplotlib import pyplot as pltdataArray=[1,6,2,11,8,8,10,5,4,5,3,7,15]plt.boxplot(dataArray,labels=[\"A\"])# 结果如下图 饼图 12345678import matplotlib.pyplot as pltlabels = 'A', 'B'sizes = [15, 30]colors = ['blue', 'gold']explode = (0, 0) plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', shadow=False, startangle=90)# 结果如下图 热力图 12345from matplotlib import pyplot as plt X = [[1,2],[3,4]] plt.imshow(X) plt.colorbar()# 结果如下图 雷达图 123456789101112import matplotlib.pyplot as pltimport numpy as np# 构建角度与值theta = np.array([2.55,4.75,3,1.25,1.65])r = [20,60,40,80,20]plt.style.use('ggplot') # 使用ggplot的绘图风格plt.polar(theta*np.pi,r,\"r-\",lw=1)# 设置填充颜色，并且透明度为0.75plt.fill(theta*np.pi,r,'r',alpha=0.75)plt.ylim(0,100)plt.grid(True)#显示网格线# 结果如下图 华为云比赛画的航海图部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import pandas as pd import foliumworld_map = folium.Map()world_maplist = []lat = 0lng = 0incidents = folium.map.FeatureGroup()df = pd.read_csv(\"get_test_port.csv\",usecols = [0,1,2,3,4,5], encoding = 'gbk')af = pd.read_csv(\"loadingOrder.csv\",usecols = [0], encoding = 'gbk')for i in range(len(af)): s = af.iat[i,0] # 订单号名称 incidents = folium.map.FeatureGroup() world_map = folium.Map() #初始化地图 for j in range(len(df)): if af.iat[i,0] == df.iat[j,0]: lat = df.iat[j,2] lng = df.iat[j,1] nlat = df.iat[j,4] nlng = df.iat[j,3] # 增加红点lat与lng incidents.add_child( folium.CircleMarker( [lat, lng], radius=20, color='yellow', fill=True, fill_color='red', fill_opacity=0.4 ) ) # 增加蓝点nlat与nlng incidents.add_child( folium.CircleMarker( [nlat, nlng], radius=5, color='yellow', fill=True, fill_color='blue', fill_opacity=0.4 ) ) #world_map = folium.Map(location=[lat, lng], zoom_start=20) # 选择一个点为比例尺 world_map.add_child(incidents) #将点放入地图 folium.Marker([nlat, nlng], popup=df.iat[j,5]).add_to(world_map)#对点做标记 s = af.iat[i,0] + \".html\" #m = folium.Map(location=[nlat, nlng]) world_map.save(s.format(af.iat[i,0])) print(af.iat[i,0] + \"已生成\") 列举其中一张图","link":"/2020/10/12/Python/"}],"tags":[{"name":"python","slug":"python","link":"/tags/python/"},{"name":"daily","slug":"daily","link":"/tags/daily/"},{"name":"data structure","slug":"data-structure","link":"/tags/data-structure/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"game","slug":"game","link":"/tags/game/"}],"categories":[{"name":"code","slug":"code","link":"/categories/code/"},{"name":"c++","slug":"code/c","link":"/categories/code/c/"},{"name":"Tutorials","slug":"Tutorials","link":"/categories/Tutorials/"}]}