{"pages":[{"title":"","text":"一只兔子","link":"/about/index.html"}],"posts":[{"title":"Double Linked List","text":"1.为什么要用链表大家在存储多组数据时，会选用数组，但在数组中间删减或是增加数据时，需要将整个数组往前后“平移”。 增加： 12345678void Add(int value, int index, int size){ for(int i = index, i &lt;= size; i++) { a[i+1] = a[i]; } a[index] = value;} 删减： 1234567void Delete(int v, int size){ for(int i = index, i &lt;= size; i++) { a[i] = a[i+1]; }} 这样的时间复杂度会很高，也十分麻烦，需要遍历一遍才能完成操作，而链表可以之前在中间插入、删除。 2.双链表模型一般来说，链表有“head”与“tail”，头与尾的中间用来存储数据，每个节点都有两个指针，指向节点的前后。 next：后指针，代表这个节点的下一个节点。 pre：前指针，代表这个节点的上一个节点。 3.创建双链表需要一个data数据、前指针和后指针，我们使用结构体将它们封装起来。 123456struct list{ int value;//数据 list *next;//后指针 list *pre;//前指针};//链表结构体 4.初始化我们已经创建好了一个链表，那么需要对它进行初始化操作，书写初始化函数。 我们需要为head和tail开一个新的空间，否则将成为一个没空间没内存的“野指针”。 12345678910void initialization(list *&amp;head, list *&amp;tail)//传入头指针与尾指针{ head = new list (); tail = new list (); //为head、tail开空间 head -&gt; next = tail;//head的\"next\"指向tail head -&gt; pre = NULL;//head的\"pre\"指向NULL(空) tail -&gt; pre = head;//tail的\"next\"指向tail tail -&gt; next = NULL;//tail的\"next\"指向NULL(空)}//初始化 5.插入、删除那么链表的插入、删除是怎样实现的呢？ 插入我们想将一个new data插入data之后，我们需要将data的“next”指针指向new data，Tail的“pre”指针指向new data，new data的“next”指针指向TAIL、“pre”指针指向data。 1234567891011void insert(list *&amp;tail, int v){ list *p = new list (); list *q = new list (); q = tail -&gt; pre; p -&gt; value = v; p -&gt; next = tail; tail -&gt; pre = p; p -&gt; pre = q; q -&gt; next = p;}//添加 删除若想将data删掉，我们需要将HAED的“next”指针指向TAIL，TAIL的“pre”指针指向HEAD。 123456789101112131415void Delete(list *&amp;head, int v){ list *p = head; p = p -&gt; next; while(p -&gt; next != NULL) { if(p -&gt; value == v) { p -&gt; next -&gt; pre = p -&gt; pre; p -&gt; pre -&gt; next = p -&gt; next; break; } p = p -&gt; next; }}//删除 6.打印若想将链表中的数据打印出来，需要从head开始向后循环，”head-&gt;value“代表head节点指向的数据，每打印一个数据后，将head替换为”head-&gt;next“,也就是head现在指向的是head的下一个，直到head为空时，也就是head打印最后一个数据后，结束打印。 1234567891011void print(list *head){ cout &lt;&lt; \"开始打印\" &lt;&lt; endl; head = head -&gt; next; while(head -&gt; next != NULL) { cout &lt;&lt; head -&gt; value &lt;&lt; endl; head = head -&gt; next; } cout &lt;&lt; \"结束打印\" &lt;&lt; endl; }//打印 7.清空删除每一个节点指针，循环下去。需要注意的是，我们需要创建一个新的指针来存储删除前指针的下一个指针，这是因为节点被删除后就不具备指向下一个的作用了，会导致找不到节点而出现很多问题。 1234567891011121314void Empty(list *head){ list *p = new list (); list *HEAD = head; HEAD = HEAD -&gt; next; while(HEAD -&gt; next != NULL) { p = HEAD -&gt; next; HEAD -&gt; next -&gt; pre = HEAD -&gt; pre; HEAD -&gt; pre -&gt; next = HEAD -&gt; next; delete HEAD; HEAD = p; }}//清空 8.完整代码网上很多代码都写了“typedef”，身边一些同学也这么写过，据了解后发现“typedef”在c语言书写时会较轻松。因为c语言在定义一个指针时不能直接“list xxx”，而需要“struct list xxx”。 传参时是否加“&amp;”，是根据你的功能是否需要修改链表的头指针的值，若不改变使用“*”即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;using namespace std;struct list{ int value;//数值 list *next;//下一个 list *pre;//上一个 };//链表结构体 int x;void initialization(list *&amp;head, list *&amp;tail){ head = new list (); tail = new list (); head -&gt; next = tail; head -&gt; pre = NULL; tail -&gt; pre = head; tail -&gt; next = NULL;}//初始化 void insert(list *&amp;tail, int v){ list *p = new list (); list *q = new list (); q = tail -&gt; pre; p -&gt; value = v; p -&gt; next = tail; tail -&gt; pre = p; p -&gt; pre = q; q -&gt; next = p;}//添加 void Empty(list *&amp;head){ list *p = new list (); list *HEAD = head; HEAD = HEAD -&gt; next; while(HEAD -&gt; next != NULL) { p = HEAD -&gt; next; HEAD -&gt; next -&gt; pre = HEAD -&gt; pre; HEAD -&gt; pre -&gt; next = HEAD -&gt; next; delete HEAD; HEAD = p; } }//清空void Delete(list *&amp;head, int v){ list *p = head; p = p -&gt; next; while(p -&gt; next != NULL) { if(p -&gt; value == v) { p -&gt; next -&gt; pre = p -&gt; pre; p -&gt; pre -&gt; next = p -&gt; next; break; } p = p -&gt; next; }}//删除void print(list *head){ cout &lt;&lt; \"开始打印\" &lt;&lt; endl; head = head -&gt; next; while(head -&gt; next != NULL) { cout &lt;&lt; head -&gt; value &lt;&lt; endl; head = head -&gt; next; } cout &lt;&lt; \"结束打印\" &lt;&lt; endl; }//打印 int main(){ list *head, *tail; initialization(head, tail); while(1) { cout &lt;&lt; \"1.insert\" &lt;&lt; endl &lt;&lt; \"2.Empty\" &lt;&lt; endl &lt;&lt; \"3.print\" &lt;&lt; endl &lt;&lt; \"4.Delete\" &lt;&lt; endl &lt;&lt; \"5.EXIT\" &lt;&lt; endl; cin &gt;&gt; x; switch(x) { case 1: cin &gt;&gt; x; insert(tail, x); break; case 2: Empty(head); break; case 3: print(head); break; case 4: cin &gt;&gt; x; Delete(head, x); break; case 5: return 0; } } return 0;}","link":"/2019/11/03/List/"},{"title":"Snake","text":"学年设计的时候做的贪吃蛇，只是简单的做出来基本操作，写的代码从时间和空间上看都不是很优。 这里讲一下大概思路： 一条蛇不停的移动， 玩家将控制蛇的方向，蛇在吃掉食物后，将会重新生成食物，若蛇吃到自己的身体或撞到边框则结束游戏并显示得分。 一个最简贪吃蛇游戏需要3个部分： 1.地图 2.蛇移动 3.食物 地图地图使用了坐标函数设置，画一个框 移动贪吃蛇的移动分为按键控制与在未有按键输入时向原方向移动。 按键控制使用kbhit()函数接受即可设置蛇的移动。 在未出现按键输入时，蛇将不停的向原方向移动(将每个蛇的坐标向前覆盖并清除最后一个坐标)，还需要使用sleep()函数与循环。 sleep()函数可以在一定时间让蛇停下来(不然刚开局就死掉了)。 食物食物需要在蛇吃掉后随机生成，且不能生成在蛇的身上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296#include&lt;iostream&gt;#include &lt;windows.h&gt; #include&lt;ctime&gt;#include&lt;queue&gt;#include&lt;conio.h&gt;//内含有kbhit()函数 在VC里面有这个头文件#define Up 119//72 #define Down 115 //80 #define Left 97 //75#define Right 100 //77#define Enter 13//上，下，左，右//system(\"cls\");//清屏函数 using namespace std;//////////全局变量////////////HANDLE hOut,hIn,hwnd;bool alive;//是否存活int grade=0;//得分char key;char direction;//方向bool kk=false;int length=2;//初始长度bool f=false;//是否已经生成食物int sx[100];//snake横坐标int sy[100];//snake纵坐标int food_x;//food横坐标int food_y;//food纵坐标int x,y,QAQ;char QWQ;///////////////////////////////void HideCursor(int n) /*隐藏光标*/{ CONSOLE_CURSOR_INFO cursor_info={1,n}; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE),&amp;cursor_info);}//////////////颜色函数/////////////////int color(int c){ hOut=GetStdHandle(STD_OUTPUT_HANDLE);//获取字符输出句柄 SetConsoleTextAttribute(hOut,c);//改变颜色 return 0; } void setXY(int x,int y) //移动坐标{ COORD coord; coord.X=x; coord.Y=y; SetConsoleCursorPosition( GetStdHandle( STD_OUTPUT_HANDLE ), coord );}///////////////////////////////////// ////////////画图///////////////////void Interface_Design(){ for(int i=0;i&lt;24;i++) { setXY(0,i); cout&lt;&lt;\"#\"; setXY(40,i); cout&lt;&lt;\"#\"; } for(int i=0;i&lt;=40;i++) { setXY(i,0); cout&lt;&lt;\"#\"; setXY(i,24); cout&lt;&lt;\"#\"; } setXY(50,20); cout&lt;&lt;\"操作\"; setXY(50,22); cout&lt;&lt;\"w s a d 控制上下左右\";}/////////////////////////////////////////////////画蛇//////////////////// void snake(){ for(int i=0;i&lt;length;i++) { setXY(sx[i],sy[i]); if(i==0) cout&lt;&lt;\"@\"; else cout&lt;&lt;\"*\"; }}void xY(){ for(int i=length-1;i&gt;=1;i--) { sx[i]=sx[i-1]; sy[i]=sy[i-1]; }}//坐标移动 ///////////////////////////////////////// void food() { int x,y; srand((unsigned int)time(NULL)); int ww=1; while(ww) { for(int i=0;i&lt;20;i++) { x=rand()%(20-4)+2; y=rand()%(20-2)+1; } for(int i=0;i&lt;length;i++) { ww=0; if(sx[i]==x&amp;&amp;sy[i]==y) { ww=1; break; } }//不能再蛇的身体上生成食物 } setXY(x,y); food_x=x; food_y=y; cout&lt;&lt;'$'; f=true;}//食物生成函数 void L(){ if(sx[0]==food_x&amp;&amp;sy[0]==food_y) { f=false; length++; sx[length-1]=sx[length-2]; sy[length-1]=sy[length-2]; }}//对蛇是否吃掉食物进行判定，并增加蛇的长度////////////方向控制 ////////////////void Control_Direction(){ switch(key) { case Up: direction=Up; L(); setXY(sx[length-1],sy[length-1]); cout&lt;&lt;\" \";xY(); sy[0]--; setXY(sx[0],sy[0]); snake(); break; case Down:direction=Down; L(); setXY(sx[length-1],sy[length-1]); cout&lt;&lt;\" \"; xY(); sy[0]++; setXY(sx[0],sy[0]); snake(); break; case Left:direction=Left; L(); setXY(sx[length-1],sy[length-1]); cout&lt;&lt;\" \";xY(); sx[0]--; setXY(sx[0],sy[0]); snake(); break; case Right:direction=Right; L(); setXY(sx[length-1],sy[length-1]); cout&lt;&lt;\" \";xY(); sx[0]++; setXY(sx[0],sy[0]); snake(); break; }} //////////////////////////////////////////////////////死亡/////////////////void dead(){ if(sx[0]&gt;39||sx[0]&lt;1||sy[0]&lt;1||sy[0]&gt;23) { alive=false; } for(int i=1;i&lt;length;i++) { if(sx[0]==sx[i]&amp;&amp;sy[0]==sy[i]) { alive=false; } }}///////////////////////////////////// ////////////////菜单///////////////////int menu(){ setXY(50,5); cout&lt;&lt;\" 贪吃蛇游戏\"&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl; setXY(50,10); cout&lt;&lt;\" 普通模式\"&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl; setXY(50,15); cout&lt;&lt;\" 困难模式\"&lt;&lt;endl; setXY(15,25); cout&lt;&lt;\"w s上下选择 回车 确认选择\"; setXY(30,10); while(kbhit()) { HideCursor(0); QWQ=getch(); if(QWQ==Up) { setXY(30,15); cout&lt;&lt;\" \"; setXY(30,10); cout&lt;&lt;\"---------&gt;&gt;&gt;\"; x=30; y=10; } else if(QWQ==Down) { setXY(30,10); cout&lt;&lt;\" \"; setXY(30,15); cout&lt;&lt;\"---------&gt;&gt;&gt;\"; x=30; y=15; } else if(QWQ==13) { if(y==10) return 1; if(y==15) return 2; } }} /////////////////////////////////////int main(){ int mm=1; HideCursor(0); x=30;y=10; setXY(30,10); cout&lt;&lt;\"---------&gt;&gt;&gt;\"; while(QWQ!=13) { Sleep(200); mm=menu(); } system(\"cls\");//清屏函数 setXY(5,5); if(mm==1) QAQ=200; else if(mm==2) QAQ=170-length*2; color(3); HideCursor(0); alive=true; srand(time(NULL)); Interface_Design(); //界面设计 sx[0]=5; sy[0]=5; sx[1]=4; sy[1]=5; snake(); key=Right; direction=0; while(1) { color(6); if(!f)food(); color(2); Sleep(QAQ); if(kbhit()) { if((key=getch())==-32) key=getch(); } if(key==Up&amp;&amp;direction==Down) key=Down; else if(key==Down&amp;&amp;direction==Up) key=Up; else if(key==Right&amp;&amp;direction==Left) key=Left; else if(key==Left&amp;&amp;direction==Right) key=Right; Control_Direction(); dead(); if(!alive) break; setXY(50,25); cout&lt;&lt;\"得分:\"&lt;&lt;(length-2)*2&lt;&lt;endl; } color(7); system(\"cls\");//清屏函数 cout&lt;&lt;\"GAME OVER\"&lt;&lt;endl; cout&lt;&lt;\"得分:\"&lt;&lt;(length-2)*2&lt;&lt;endl; system(\"pause\");return 0; } 这里我还加了颜色改变和主菜单，也十分简单，使用坐标函数即可。 如果想要显示最高分的话我想的是使用文件那一块的知识。","link":"/2019/07/23/Snake/"},{"title":"Merge Sort / Quickly Sort / Shell Sort","text":"这次我们介绍三种排序手写方法：Merge Sort、Quickly Sort 、Shell Sort. 本文排序都使用的字符串组。 Merge SortMerge Sort 也称为归并排序，算法如下： 归并排序是将两个已经处理好的上升序列整合在一起成为一个新的上升序列。 算法：将两个序列从左到右依次对比比较，分别设定两个序列的头尾指向，对比此时下标两个序列相对应的数字，小的则放入整合序列中，更新下标，若相等，则任意一个放入整合序列中，若其中一个序列已经放完，则按照顺序将另一个序列全部放入整合序列中。 1234567891011121314//s1、s2为两个上升序列，s3为整合序列//l1、r1，l2、r2,分别为两个上升序列的头尾下标void Merge_Sort(string *&amp;s1, int l1, int r1, string *&amp;s2, int l2, int r2, string *&amp;s3){ int i1 = l1, i2 = l2; int len = 0;//整合序列的长度 while(i1 &lt;= r1 &amp;&amp; i2 &lt;= r2) { if(s1[i1] &gt;= s2[i2]) s3[++len] = s2[i2++]; else s3[++len] = s1[i1++]; } for(int i = i1; i &lt;= r1; i++) s3[++len] = s1[i]; for(int i = i2; i &lt;= r2; i++) s3[++len] = s2[i];} Quickly SortQuickly Sort也就是头文件algorithm中的内置sort函数，而且它真的很快！ 那么为什么要学习手写呢？因为在一些比赛或考试中不能使用内置函数sort，只能手写。 算法：从数列中取出一个基准数，然后以此为基准，比基准数大的数字都放在它的右边，将比基准数小的数都放在它的左边，然后对左右子区间采用相同的方法，直到每个区间只有一个数。 12345678910111213141516void Sort(string *&amp;a,int l, int r){ string x = a[l];//取出一个数 int i = l, j = r;//左右下标 if(l &gt;= r) return ; while(i &lt; j) { while(i &lt; j &amp;&amp; x &lt;= a[j]) j--;//从右到左找到一个小于x的 if(i &lt; j) a[i++] = a[j]; while(i &lt; j &amp;&amp; a[i] &lt;= x) i++;//从左到右找到一个大于x的 if(i &lt; j) a[j--] = a[i]; } a[i] = x;//将它放中间 Sort(a, l, i - 1); Sort(a, i + 1, r);} Shell SortShell Sort又叫希尔排序，是一种排序演化而成的排序方式。 算法：开始时：将序列区分为n/2个间隔，将相同间隔的数进行排序，减小间隔数，按照以上操作继续排序，直到间隔为1停止。 1234567891011121314151617void Shellsort(int a[], int n){ int tmp, i, j; for(int Increment = n / 2; Increment &gt; 0; Increment /= 2) { for(i = Increment; i &lt; n; i++) { tmp = a[i]; for(j = i; j &gt;= Increment; j -= Increment) { if(tmp &lt; a[j - Increment]) a[j] = a[j - Increment]; else break; } a[j] = tmp; } }}","link":"/2019/12/10/Sort/"},{"title":"HELLO WORLD","text":"1234567#include&lt;iostream&gt;using namespace std;int main(){ cout&lt;&lt;\"HELLO WORLD\"; return 0;}","link":"/2019/07/11/first/"},{"title":"Binary Tree Calculator","text":"1.基本思路​ Binary tree calculator也就是使用二叉树实现计算器的功能，相信大家以前都使用栈实现过计算器功的能，使用两个栈分别存数字与字符，一边计算一边“pop”、“push”，或是先将输入的中缀表达式转为后缀表达式，之后运算。而我们的Binary tree calculator则也需要用到栈，先将中缀表达式转为后缀表达式，之后使用指针栈构建Expression tree，再利用二叉树节点之间的关系递推遍历计算即可。 2.中缀表达式转后缀表达式那么怎么才能将中缀表达式转为后缀表达式呢？我们来看下面一个例子。 ​ a+b*(c-d)/e 上述则为一个中缀表达式，它的后缀表达式如下： ​ abcd-*e/+ 我们利用栈来实现这个过程： (1)若遇到数字直接输出。 (2)若遇到字符(‘+’、’-‘、’*’、’/‘),对比栈顶元素的优先级，如果比栈顶元素优先级高，则直接入栈，否则将栈中元素不断出栈，直到出现优先级比存入字符低，则将字符入栈。 (3)若字符为’(‘,则直接入栈，若遇到‘)’，则将‘(’前的元素弹出。 (4)若扫描完成后栈中还有元素滞留，则将栈中元素全部弹出。 为了使得大家清晰可见看懂，实现过程的图片每一步兔子都将它画了出来，所以图片有一点多…… 3.构建Expression tree我们将每一个数或符号都看做一个节点，在此基础上构建Expression tree。 创建一个指针栈，遍历后缀表达式，若遇到数字则作为一个节点存入指针栈，若遇到符号则取出栈中两个节点作为此节点的左右儿子，再将节点存入栈中，以此类推。当后缀表达式被完全遍历后，栈中将只存在一个节点指针，此指针则为树的根节点。 4.计算Expression tree我们已经建立好了Expression tree，现在我们只需要计算出值就可以完成我们的Binary tree calculator了！ 那么…..要怎么计算呢？ 兔子思考了一下，发现可以使用递归的方法计算答案！ 我们从树的根节点开始从上往下遍历，每遇到一个符号则在使用此函数返回与符号相符的运算式，直到遇到数字则返回数字本身的值。 例如，根节点为‘+’，则return 计算'+'的左节点的值 + 计算'+'右节点的值，而为了得到左右节点的值，函数会继续运算，当遇到‘+’的左儿子则return a，当遇到右儿子‘/’则会继续返回左右儿子的计算值return计算'/'的左节点的值 / 计算'/'右节点的值,而为了得到左右节点的值，函数会继续运算，当遇到左儿子‘*’则会继续返回左右儿子的计算值return计算 * 的左节点的值 * 计算 * 右节点的值,而为了得到左右节点的值，函数会继续运算，当遇到 * 的左儿子则return b，当遇到右儿子‘-’则会继续返回左右儿子的计算值return计算'-'的左节点的值 - 计算'-'右节点的值,而为了得到左右节点的值，函数会继续运算，当遇到‘-’的左儿子则return c，当遇到右儿子则 return d,当遇到‘/’的右儿子则return e. 经历了层层的递归返回，我们将得到最终表达式答案！ 5.完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;cmath&gt;using namespace std;double QAQ(string pe){ double num1=0; double num2=0; int size = 0; int f = 1; for(int i = 0; i &lt; pe.length(); i++) { if(pe[i] == '.') { f = 0; continue; } if(f) num1 = num1 * 10 + pe[i] - '0'; else { num2 = num2 * 10 + pe[i] - '0'; size ++; } } return (num1 + num2 / pow(10,size)); }void ppe(string ix,string &amp;pe)//中缀转后缀 { stack&lt;char&gt; QWQ; for(int i = 0; i &lt; ix.length(); i++) { if((ix[i] &lt;= '9' &amp;&amp; ix[i] &gt;= '0') || ix[i] == '.') { while((ix[i] &lt;= '9' &amp;&amp; ix[i] &gt;= '0') || ix[i] == '.') { pe += ix[i]; i++; } pe +=' '; i--; }//数字直接放 else if((ix[i] == '+' || ix[i] == '-')) { if(QWQ.empty() || QWQ.top() == '(') { QWQ.push(ix[i]); } else { while(!QWQ.empty()) { if(QWQ.top() == '(') break; pe += QWQ.top(); QWQ.pop(); } QWQ.push(ix[i]); } } else if((ix[i] == '*' || ix[i] == '/')) { if(QWQ.empty() || QWQ.top() == '+' || QWQ.top() == '-') { QWQ.push(ix[i]); } else { while(!QWQ.empty()) { if(QWQ.top() == '+'|| QWQ.top() == '-'|| QWQ.top() == '(') break; pe += QWQ.top(); QWQ.pop(); } QWQ.push(ix[i]); } } else if(ix[i] == '(') { QWQ.push(ix[i]); } else if(ix[i] == ')') { while(QWQ.top() != '(') { pe += QWQ.top(); QWQ.pop(); } QWQ.pop(); } } while(!QWQ.empty()) { pe += QWQ.top(); QWQ.pop(); } cout &lt;&lt; pe &lt;&lt; endl; }struct tree{ string data; tree *left; tree *right;};//一棵树 void insert(string value,stack&lt;tree *&gt; &amp;ss,int flag)// { tree *t = new tree(); t -&gt; data = value; t -&gt; left = NULL; t -&gt; right = NULL; if(!ss.empty() &amp;&amp; flag) { tree *p1 = ss.top(); ss.pop(); tree *p2 = ss.top(); ss.pop(); t -&gt; left = p2; t -&gt; right = p1; } ss.push(t);} tree *creat_tree(string pe,stack&lt;tree *&gt; &amp;ss)//建立表达式树 { for(int i = 0; i &lt; pe.length(); i++) { string num_ex = \"\"; string ch_ex = \"\"; if((pe[i] &lt;= '9' &amp;&amp; pe[i] &gt;= '0') || pe[i] == '.') { while(pe[i] != ' ') { num_ex += pe[i]; i++; } insert(num_ex, ss,0); } else { ch_ex += pe[i]; insert(ch_ex, ss,1); } } tree *tmp = ss.top(); return ss.top();}double Calculator(tree *t)//计算器 { if(t -&gt; data == \"+\") return Calculator(t -&gt; left) + Calculator(t -&gt; right); else if(t -&gt; data == \"-\") return Calculator(t -&gt; left) - Calculator(t -&gt; right); else if(t -&gt; data == \"*\") return Calculator(t -&gt; left) * Calculator(t -&gt; right); else if(t -&gt; data == \"/\") return Calculator(t -&gt; left) / Calculator(t -&gt; right); else return QAQ(t -&gt; data);} int main(){ string ix; string pe; stack&lt;tree *&gt; ss;//指针栈 cin &gt;&gt; ix; ppe(ix,pe); cout &lt;&lt; Calculator(creat_tree(pe,ss)) &lt;&lt; endl; return 0;}","link":"/2019/11/17/tree/"}],"tags":[{"name":"data structure","slug":"data-structure","link":"/tags/data-structure/"},{"name":"game","slug":"game","link":"/tags/game/"},{"name":"daily","slug":"daily","link":"/tags/daily/"}],"categories":[{"name":"code","slug":"code","link":"/categories/code/"}]}